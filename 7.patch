From: Leonid Bobrov <goleo@disroot.org>
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=disroot.org; s=mail;
	t=1592466143; bh=omDbnZo/TwTPeLAdcGesD6pHM40Tj3IT0N5/mFF1xTs=;
	h=From:To:Cc:Subject:Date:In-Reply-To:References;
	b=PJlNpvAPJmo6g1YqTZwk1j9YMwvtmGUkrSIBy5YrslbZNHS0nDx8CYl3HuxJmE6Ex
	 E1CH5DWrMrrpRnYYN9TLqt2HrIFJWdKe/ZlU6Z0WAHChEPcoOF9N7kkoY/EfGKcpUN
	 gxL8nFRuySGZj15h0mXc+2NId7xB6cTul9ld6fh8+4hQBX6YqiKOxX/RvpmpDBIGt8
	 V3utm4vO4/RPvZAAyykV1odaoSfbmodp96SGeF2yrjUoZbWstrcdpDFZPfspXcerZp
	 ku3XCr8R2TJPDvMxad/EGcYP+l+CZpSuQQ+/KBx2s+QZtTHh5mlPHaHDzQQ36gvtsz
	 Rq6IObzYq4rQA==
To: ~sircmpwn/wio@lists.sr.ht,
	Leon Plickat <leonhenrik.plickat@stud.uni-goetttingen.de>
Cc: Leonid Bobrov <goleo@disroot.org>
Subject: [PATCH 07/11] Remove duplicate code in New, Resize and resize by dragging borders
Date: Thu, 18 Jun 2020 10:39:50 +0300
Message-Id: <20200618073954.189606-8-goleo@disroot.org>
In-Reply-To: <20200618073954.189606-1-goleo@disroot.org>
References: <20200618073954.189606-1-goleo@disroot.org>
Mime-Version: 1.0
Content-Transfer-Encoding: quoted-printable

---
 include/view.h |   4 +-
 input.c        |  34 ++++--------
 output.c       |  20 ++-----
 view.c         | 144 +++++++++++++++++++++----------------------------
 4 files changed, 75 insertions(+), 127 deletions(-)

diff --git a/include/view.h b/include/view.h
index e1a8bbf..0899f9c 100644
--- a/include/view.h
+++ b/include/view.h
@@ -5,9 +5,6 @@
=20
 #define MINWIDTH 100
 #define MINHEIGHT 100
-// TODO: scale
-#define less_swap1(A, B) { if (A < B) { int C =3D A; A =3D B + window_bo=
rder * 2; B =3D C + window_border * 2; } }
-#define less_swap2(A, B) { if (A < B) { int C =3D A; A =3D B - window_bo=
rder * 2; B =3D C - window_border * 2; } }
=20
 struct wio_server;
=20
@@ -37,6 +34,7 @@ void server_new_xdg_surface(struct wl_listener *listene=
r, void *data);
=20
 void wio_view_focus(struct wio_view *view, struct wlr_surface *surface);
 struct wlr_box which_box(struct wio_server *server);
+struct wlr_box canon_box(struct wio_server *server, struct wlr_box box);
 struct wio_view *wio_view_at(struct wio_server *server, double lx, doubl=
e ly,
 		struct wlr_surface **surface, double *sx, double *sy);
 void wio_view_move(struct wio_view *view, int x, int y);
diff --git a/input.c b/input.c
index 8e79f0e..9640b9c 100644
--- a/input.c
+++ b/input.c
@@ -220,19 +220,12 @@ static void view_end_interactive(struct wio_server =
*server) {
 }
=20
 static void new_view(struct wio_server *server) {
-	int x1 =3D server->interactive.sx, x2 =3D server->cursor->x;
-	int y1 =3D server->interactive.sy, y2 =3D server->cursor->y;
-	less_swap2(x2, x1);
-	less_swap2(y2, y1);
-	int width =3D x2 - x1, height =3D y2 - y1;
-	if (width < MINWIDTH || height < MINHEIGHT) {
+	struct wlr_box box =3D which_box(server);
+	if (box.width < MINWIDTH || box.height < MINHEIGHT) {
 		return;
 	}
 	struct wio_new_view *view =3D calloc(1, sizeof(struct wio_new_view));
-	view->box.x =3D x1;
-	view->box.y =3D y1;
-	view->box.width =3D width;
-	view->box.height =3D height;
+	view->box =3D box;
 	int fd[2];
 	if (pipe(fd) !=3D 0) {
 		wlr_log(WLR_ERROR, "Unable to create pipe for fork");
@@ -290,8 +283,6 @@ static void handle_button_internal(
 		.width =3D server->menu.width, .height =3D server->menu.height,
 	};
 	struct wlr_box box;
-	int x1, x2, y1, y2;
-	uint32_t width, height;
 	double sx, sy;
 	struct wlr_surface *surface =3D NULL;
 	struct wio_view *view;
@@ -334,7 +325,7 @@ static void handle_button_internal(
 		view =3D wio_view_at(server, server->cursor->x, server->cursor->y, &su=
rface, &sx, &sy);
 		if (view !=3D NULL) {
 			view_begin_interactive(view, surface, sx, sy,
-					"bottom_right_corner", INPUT_STATE_RESIZE_START);
+					"top_left_corner", INPUT_STATE_RESIZE_START);
 		} else {
 			view_end_interactive(server);
 		}
@@ -349,24 +340,17 @@ static void handle_button_internal(
 		break;
 	case INPUT_STATE_BORDER_DRAG:
 		box =3D which_box(server);
-		x1 =3D box.x, y1 =3D box.y, width =3D box.width, height =3D box.height=
;
+		box =3D canon_box(server, box);
 		goto Done;
 	case INPUT_STATE_RESIZE_END:
-		x1 =3D server->interactive.sx, x2 =3D server->cursor->x;
-		y1 =3D server->interactive.sy, y2 =3D server->cursor->y;
-		less_swap2(x2, x1);
-		less_swap2(y2, y1);
-		width =3D x2 - x1;
-		height =3D y2 - y1;
-		if (width < MINWIDTH || height < MINHEIGHT) {
+		box =3D which_box(server);
+		if (box.width < MINWIDTH || box.height < MINHEIGHT) {
 			view_end_interactive(server);
 			break;
 		}
 	Done:
-		wio_view_move(server->interactive.view,
-				x1, y1);
-		wlr_xdg_toplevel_set_size(
-				server->interactive.view->xdg_surface, width, height);
+		wio_view_move(server->interactive.view, box.x, box.y);
+		wlr_xdg_toplevel_set_size(server->interactive.view->xdg_surface, box.w=
idth, box.height);
 		view_end_interactive(server);
 		break;
 	case INPUT_STATE_MOVE_SELECT:
diff --git a/output.c b/output.c
index 3ec64a8..28efb2f 100644
--- a/output.c
+++ b/output.c
@@ -273,7 +273,6 @@ static void output_frame(struct wl_listener *listener=
, void *data) {
 	struct wio_server *server =3D output->server;
 	struct wlr_renderer *renderer =3D server->renderer;
 	struct wlr_box box;
-	int x, y, width, height;
 	float color[4];
=20
 	struct timespec now;
@@ -313,6 +312,7 @@ static void output_frame(struct wl_listener *listener=
, void *data) {
 	switch (server->input_state) {
 	case INPUT_STATE_BORDER_DRAG:
 		box =3D which_box(server);
+		box =3D canon_box(server, box);
 		render_view_border(renderer, output, NULL, box.x, box.y, box.width, bo=
x.height, 1);
 		break;
 	case INPUT_STATE_MOVE:
@@ -325,24 +325,12 @@ static void output_frame(struct wl_listener *listen=
er, void *data) {
 		break;
 	case INPUT_STATE_NEW_END:
 	case INPUT_STATE_RESIZE_END:
-		x =3D server->interactive.sx;
-		y =3D server->interactive.sy;
-		width =3D server->cursor->x - server->interactive.sx;
-		height =3D server->cursor->y - server->interactive.sy;
-		if (width < 0) {
-			width *=3D -1;
-			x -=3D width + window_border * 2;
-		}
-		if (height < 0) {
-			height *=3D -1;
-			y -=3D height + window_border * 2;
-		}
-		if (width > 0 && height > 0) {
-			box.x =3D x, box.y =3D y, box.width =3D width, box.height =3D height;
+		box =3D which_box(server);
+		if (box.width > 0 && box.height > 0) {
 			memcpy(color, surface, sizeof(color));
 			wlr_render_rect(renderer, &box, color, output->wlr_output->transform_=
matrix);
 		}
-		render_view_border(renderer, output, NULL, x, y, width, height, 1);
+		render_view_border(renderer, output, NULL, box.x, box.y, box.width, bo=
x.height, 1);
 		break;
 	default:
 		break;
diff --git a/view.c b/view.c
index 31697da..fc7ccc7 100644
--- a/view.c
+++ b/view.c
@@ -5,6 +5,10 @@
 #include "server.h"
 #include "view.h"
=20
+// TODO: scale
+#define less_swap1(A, B) { if (A < B) { int C =3D A; A =3D B + window_bo=
rder * 2; B =3D C + window_border * 2; } }
+#define less_swap2(A, B) { if (A < B) { int C =3D A; A =3D B - window_bo=
rder * 2; B =3D C - window_border * 2; } }
+
 static void xdg_surface_map(struct wl_listener *listener, void *data) {
 	struct wio_view *view =3D wl_container_of(listener, view, map);
 	struct wio_server *server =3D view->server;
@@ -143,133 +147,107 @@ static int which_corner(struct wlr_box *box, int =
x, int y) {
=20
 struct wlr_box which_box(struct wio_server *server) {
 	struct wlr_box box;
-	int x1, x2, y1, y2, width, height;
+	int x1, x2, y1, y2;
+
+	if (server->interactive.view =3D=3D NULL) {
+		goto End;
+	}
+	x2 =3D server->interactive.sx + server->interactive.view->xdg_surface->=
surface->current.width;
+	y2 =3D server->interactive.sy + server->interactive.view->xdg_surface->=
surface->current.height;
 	switch (server->interactive.view->area) {
 	case VIEW_AREA_BORDER_TOP_LEFT:
 		y1 =3D server->cursor->y;
-		y2 =3D server->interactive.view->y + server->interactive.view->xdg_sur=
face->surface->current.height;
 		x1 =3D server->cursor->x;
-		x2 =3D server->interactive.view->x + server->interactive.view->xdg_sur=
face->surface->current.width;
 		less_swap1(y2, y1);
 		less_swap1(x2, x1);
-		width =3D x2 - x1;
-		if (width < MINWIDTH
-			&& (x1 - server->interactive.view->x) < (server->interactive.view->xd=
g_surface->surface->current.width)) {
-			x1 -=3D MINWIDTH - width;
-		}
-		height =3D y2 - y1;
-		if (height < MINHEIGHT
-			&& (y1 - server->interactive.view->y) < (server->interactive.view->xd=
g_surface->surface->current.height)) {
-			y1 -=3D MINHEIGHT - height;
-		}
 		break;
 	case VIEW_AREA_BORDER_TOP:
 		y1 =3D server->cursor->y;
-		y2 =3D server->interactive.view->y + server->interactive.view->xdg_sur=
face->surface->current.height;
-		x1 =3D server->interactive.view->x;
+		x1 =3D server->interactive.sx;
 		less_swap1(y2, y1);
-		width =3D server->interactive.view->xdg_surface->surface->current.widt=
h;
-		height =3D y2 - y1;
-		if (height < MINHEIGHT
-			&& (y1 - server->interactive.view->y) < (server->interactive.view->xd=
g_surface->surface->current.height)) {
-			y1 -=3D MINHEIGHT - height;
-		}
 		break;
 	case VIEW_AREA_BORDER_TOP_RIGHT:
 		y1 =3D server->cursor->y;
-		y2 =3D server->interactive.view->y + server->interactive.view->xdg_sur=
face->surface->current.height;
-		x1 =3D server->interactive.view->x;
+		x1 =3D server->interactive.sx;
 		x2 =3D server->cursor->x;
 		less_swap1(y2, y1);
 		less_swap2(x2, x1);
-		width =3D x2 - x1;
-		if (width < MINWIDTH && (x1 - server->interactive.view->x) < 0) {
-			x1 -=3D MINWIDTH - width;
-		}
-		height =3D y2 - y1;
-		if (height < MINHEIGHT
-			&& (y1 - server->interactive.view->y) < (server->interactive.view->xd=
g_surface->surface->current.height)) {
-			y1 -=3D MINHEIGHT - height;
-		}
 		break;
 	case VIEW_AREA_BORDER_LEFT:
 		x1 =3D server->cursor->x;
-		x2 =3D server->interactive.view->x + server->interactive.view->xdg_sur=
face->surface->current.width;
-		y1 =3D server->interactive.view->y;
+		y1 =3D server->interactive.sy;
 		less_swap1(x2, x1);
-		width =3D x2 - x1;
-		if (width < MINWIDTH
-			&& (x1 - server->interactive.view->x) < (server->interactive.view->xd=
g_surface->surface->current.width)) {
-			x1 -=3D MINWIDTH - width;
-		}
-		height =3D server->interactive.view->xdg_surface->surface->current.hei=
ght;
 		break;
 	case VIEW_AREA_BORDER_RIGHT:
-		x1 =3D server->interactive.view->x;
+		x1 =3D server->interactive.sx;
 		x2 =3D server->cursor->x;
-		y1 =3D server->interactive.view->y;
+		y1 =3D server->interactive.sy;
 		less_swap2(x2, x1);
-		width =3D x2 - x1;
-		if (width < MINWIDTH && (x1 - server->interactive.view->x) < 0) {
-			x1 -=3D MINWIDTH - width;
-		}
-		height =3D server->interactive.view->xdg_surface->surface->current.hei=
ght;
 		break;
 	case VIEW_AREA_BORDER_BOTTOM_LEFT:
 		x1 =3D server->cursor->x;
-		x2 =3D server->interactive.view->x + server->interactive.view->xdg_sur=
face->surface->current.width;
-		y1 =3D server->interactive.view->y;
+		y1 =3D server->interactive.sy;
 		y2 =3D server->cursor->y;
 		less_swap1(x2, x1);
 		less_swap2(y2, y1);
-		width =3D x2 - x1;
-		if (width < MINWIDTH
-			&& (x1 - server->interactive.view->x) < (server->interactive.view->xd=
g_surface->surface->current.width)) {
-			x1 -=3D MINWIDTH - width;
-		}
-		height =3D y2 - y1;
-		if (height < MINHEIGHT && (y1 - server->interactive.view->y) < 0) {
-			y1 -=3D MINHEIGHT - height;
-		}
 		break;
 	case VIEW_AREA_BORDER_BOTTOM:
-		x1 =3D server->interactive.view->x;
-		y1 =3D server->interactive.view->y;
+		x1 =3D server->interactive.sx;
+		y1 =3D server->interactive.sy;
 		y2 =3D server->cursor->y;
 		less_swap2(y2, y1);
-		width =3D server->interactive.view->xdg_surface->surface->current.widt=
h;
-		height =3D y2 - y1;
-		if (height < MINHEIGHT && (y1 - server->interactive.view->y) < 0) {
-			y1 -=3D MINHEIGHT - height;
-		}
+		box.height =3D y2 - y1;
 		break;
 	case VIEW_AREA_BORDER_BOTTOM_RIGHT:
-		x1 =3D server->interactive.view->x;
+	End:
+		x1 =3D server->interactive.sx;
 		x2 =3D server->cursor->x;
-		y1 =3D server->interactive.view->y;
+		y1 =3D server->interactive.sy;
 		y2 =3D server->cursor->y;
 		less_swap2(x2, x1);
 		less_swap2(y2, y1);
-		width =3D x2 - x1;
-		if (width < MINWIDTH && (x1 - server->interactive.view->x) < 0) {
-			x1 -=3D MINWIDTH - width;
-		}
-		height =3D y2 - y1;
-		if (height < MINHEIGHT && (y1 - server->interactive.view->y) < 0) {
-			y1 -=3D MINHEIGHT - height;
-		}
 		break;
 	}
-	if (width < MINWIDTH) {
-		width =3D MINWIDTH;
-	}
-	if (height < MINHEIGHT) {
-		height =3D MINHEIGHT;
-	}
 	box.x =3D x1;
 	box.y =3D y1;
-	box.width =3D width;
-	box.height =3D height;
+	box.width =3D x2 - x1;
+	box.height =3D y2 - y1;
+	return box;
+}
+
+struct wlr_box canon_box(struct wio_server *server, struct wlr_box box) =
{
+	if (box.width < MINWIDTH) {
+		switch (server->interactive.view->area) {
+		case VIEW_AREA_BORDER_TOP_LEFT:
+		case VIEW_AREA_BORDER_LEFT:
+		case VIEW_AREA_BORDER_BOTTOM_LEFT:
+			if ((box.x - server->interactive.sx) < server->interactive.view->xdg_=
surface->surface->current.width) {
+				box.x -=3D MINWIDTH - box.width;
+			}
+			break;
+		default:
+			if (box.x < server->interactive.sx) {
+				box.x -=3D MINWIDTH - box.width;
+			}
+		}
+		box.width =3D MINWIDTH;
+	}
+	if (box.height < MINHEIGHT) {
+		switch (server->interactive.view->area) {
+		case VIEW_AREA_BORDER_TOP_LEFT:
+		case VIEW_AREA_BORDER_TOP:
+		case VIEW_AREA_BORDER_TOP_RIGHT:
+			if ((box.y - server->interactive.sy) < server->interactive.view->xdg_=
surface->surface->current.height) {
+				box.y -=3D MINHEIGHT - box.height;
+			}
+			break;
+		default:
+			if (box.y < server->interactive.sy) {
+				box.y -=3D MINHEIGHT - box.height;
+			}
+		}
+		box.height =3D MINHEIGHT;
+	}
 	return box;
 }
=20
--=20